name: Modify Detection Rule

on:
  issues:
    types: [opened, edited]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  modify-rule:
    if: contains(github.event.issue.labels.*.name, 'modify')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract issue form data
        id: extract
        uses: actions/github-script@v7
        with:
          script: |
            const issueBody = context.payload.issue.body;
            
            // Function to extract form field value
            function extractField(body, fieldLabel) {
              const regex = new RegExp(`### ${fieldLabel}\\s*\\n+([\\s\\S]*?)(?=\\n###|$)`, 'i');
              const match = body.match(regex);
              if (match && match[1]) {
                const value = match[1].trim();
                return value === '_No response_' || value === '' ? null : value;
              }
              return null;
            }
            
            // Function to extract array fields (split by newlines)
            function extractArrayField(body, fieldLabel) {
              const value = extractField(body, fieldLabel);
              if (!value) return null;
              // Remove code block markers (```text, ```, etc.) and split by newlines
              const cleanValue = value.replace(/```\w*\n?/g, '').replace(/```/g, '');
              const array = cleanValue.split('\n').map(line => line.trim()).filter(line => line.length > 0);
              return array.length > 0 ? array : null;
            }
            
            // Function to extract checkbox selections
            function extractCheckboxes(body, fieldLabel) {
              const regex = new RegExp(`### ${fieldLabel}\\s*\\n+([\\s\\S]*?)(?=\\n###|$)`, 'i');
              const match = body.match(regex);
              if (!match || !match[1]) return null;
              
              const checkboxSection = match[1];
              const checked = [];
              const lines = checkboxSection.split('\n');
              
              for (const line of lines) {
                if (line.includes('- [X]') || line.includes('- [x]')) {
                  const labelMatch = line.match(/- \[[xX]\] (.+)/);
                  if (labelMatch) {
                    checked.push(labelMatch[1].trim());
                  }
                }
              }
              return checked.length > 0 ? checked : null;
            }
            
            // Extract all fields (null means no change)
            const data = {
              existingRuleFile: extractField(issueBody, 'Existing Rule Filename'),
              ruleName: extractField(issueBody, 'Rule Name'),
              ruleStatus: extractField(issueBody, 'Rule Status (Optional)'),
              ruleDescription: extractField(issueBody, 'Rule Description (Optional)'),
              references: extractArrayField(issueBody, 'References (Optional)'),
              modifiedBy: extractField(issueBody, 'Modified By'),
              modifiedDate: extractField(issueBody, 'Modified Date'),
              tags: extractArrayField(issueBody, 'MITRE ATT&CK Mapping (Optional)'),
              logSourceVendorCheckboxes: extractCheckboxes(issueBody, 'Vendor Data Sources \\(Optional\\)'),
              logSourceVendorCustom: extractField(issueBody, 'Custom Vendor \\(if Other selected\\)'),
              logSourceService: extractField(issueBody, 'Service Data Sources (Optional)'),
              detectionQueryBefore: extractField(issueBody, 'Detection Query Before'),
              detectionQueryAfter: extractField(issueBody, 'Detection Query After'),
              detectionQueryCondition: extractField(issueBody, 'Detection Query Condition (Optional)'),
              detectionQuerySuppress: extractField(issueBody, 'Detection Query Suppress (Optional)'),
              severity: extractField(issueBody, 'Severity (Optional)'),
              outcome: extractField(issueBody, 'Outcome (Optional)'),
              reviewLastReviewed: extractField(issueBody, 'Review Last Reviewed'),
              reviewNextReview: extractField(issueBody, 'Review Next Review'),
              expiryDate: extractField(issueBody, 'Expiry Date (Optional)'),
              changeSummary: extractField(issueBody, 'Summary of Changes')
            };
            
            // Log extracted data
            console.log('Extracted Modification Data:');
            console.log(JSON.stringify(data, null, 2));
            
            // Set output for use in next steps
            core.setOutput('modification-data', JSON.stringify(data));
            core.setOutput('rule-file', data.existingRuleFile || 'unknown');
            core.setOutput('rule-name', data.ruleName || 'unknown');
            
            return data;

      - name: Update detection rule file
        env:
          MOD_DATA: ${{ steps.extract.outputs.modification-data }}
          RULE_FILE: ${{ steps.extract.outputs.rule-file }}
        run: |
          # Install yq for YAML processing
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          
          # Parse the JSON data
          echo "$MOD_DATA" | jq .
          
          RULE_PATH="SIEM/Correlation Rules/${RULE_FILE}"
          
          # Check if file exists
          if [ ! -f "$RULE_PATH" ]; then
            echo "Error: Rule file $RULE_PATH does not exist!"
            exit 1
          fi
          
          echo "Updating existing rule: $RULE_PATH"
          
          # Create backup
          cp "$RULE_PATH" "${RULE_PATH}.backup"
          
          # Build update object with only provided fields
          UPDATE_JSON=$(echo "$MOD_DATA" | jq '{
            status: (.ruleStatus // empty | if . == "" then null else . end),
            description: (.ruleDescription // empty | if . == "" then null else . end),
            references: (.references // empty | if . == [] or . == null then null else . end),
            modified: {
              by: .modifiedBy,
              date: .modifiedDate
            },
            tags: (.tags // empty | if . == [] or . == null then null else . end),
            log_source: {
              vendor: (
                if (.logSourceVendorCheckboxes // null) != null then
                  (.logSourceVendorCheckboxes | 
                    map(if . == "Other (specify below)" then null else . end) | 
                    map(select(. != null))) +
                  (if .logSourceVendorCustom then [.logSourceVendorCustom] else [] end) |
                  if length > 0 then . else null end
                elif (.logSourceVendorCustom // null) != null then
                  [.logSourceVendorCustom]
                else
                  null
                end
              ),
              service: (.logSourceService // empty | if . == "" then null else . end)
            },
            detection: {
              query: {
                before: (.detectionQueryBefore // empty | if . == "" then null else . end),
                after: (.detectionQueryAfter // empty | if . == "" then null else . end)
              },
              condition: (.detectionQueryCondition // empty | if . == "" then null else . end),
              suppress: (.detectionQuerySuppress // empty | if . == "" then null else . end)
            },
            severity: (.severity // empty | if . == "" then null else . end),
            outcome: (.outcome // empty | if . == "" then null else . end),
            review: {
              last_reviewed: .reviewLastReviewed,
              next_review: .reviewNextReview
            },
            expiry_date: (.expiryDate // empty | if . == "" then null else . end)
          } | with_entries(select(.value != null))')
          
          echo "Update data (fields with values only):"
          echo "$UPDATE_JSON" | jq .
          
          # Merge updates with existing file using yq
          echo "$UPDATE_JSON" | yq eval-all 'select(fileIndex == 1) * select(fileIndex == 0)' "${RULE_PATH}" - > "${RULE_PATH}.new"
          mv "${RULE_PATH}.new" "$RULE_PATH"
          
          # Clean up backup
          rm "${RULE_PATH}.backup"
          
          echo ""
          echo "Updated YAML content:"
          cat "$RULE_PATH"

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          commit-message: "Modify detection rule: ${{ steps.extract.outputs.rule-name }}"
          title: "Modify Detection Rule: ${{ steps.extract.outputs.rule-name }}"
          body: |
            This PR modifies an existing detection rule based on issue #${{ github.event.issue.number }}
            
            **Rule File:** `${{ steps.extract.outputs.rule-file }}`
            **Rule Name:** ${{ steps.extract.outputs.rule-name }}
            
            **Summary of Changes:**
            ${{ fromJSON(steps.extract.outputs.modification-data).changeSummary }}
            
            Closes #${{ github.event.issue.number }}
          branch: modify-rule-${{ github.event.issue.number }}
          delete-branch: true
          labels: |
            detection-rule
            modify

      - name: Comment on issue
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: 'âœ… Detection rule has been updated and a pull request has been created. Please review the PR to see the proposed modifications.'
            })
